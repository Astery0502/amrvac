<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Manual on the amrvac.par Parameter File for MPI-AMRVAC</title>

</head>
<body>
<h1>PARAMETERS FOR MPI-AMRVAC</h1>
This document describes how the <b>amrvac.par</b>
parameter file for MPI-AMRVAC should be used. <b>Note that
default values for parameters are actually set in the module <em>amrvacio/amrio.t</em>,
you should look at subroutine <em>readparameters</em> for
details.</b>
<hr>This page:<br>
[<a href="#NAMELISTS">NAMELISTS</a>]: [<a href="#Testlist">Testlist</a>] [<a href="#Filelist">Filelist</a>]
[<a href="#Savelist">Savelist</a>] [<a href="#Stoplist">Stoplist</a>] [<a href="#Methodlist">Methodlist</a>] [<a href="#Boundlist">Boundlist</a>] [<a href="#Amrlist">Amrlist</a>]
[<a href="#Paramlist">Paramlist</a>]
<hr>
<h2><a name="NAMELISTS">NAMELISTS</a></h2>
The parameter file consists of a sequence of namelists. A namelist
consists
of an opening line, variable definitions and a closing line:
<pre> &amp;LISTNAME<br> ...VARIABLE DEFINITIONS...<br> /<br></pre>
The Fortran 90 standard for the closing line is a single slash <b>/</b>.
Any text between too namelists is
usually ignored, but on some machines such text may result in a run
time error. This is compiler dependent.
<p>Variables in a namelist can be defined by any of the following
statements:
</p>
<pre> varname=value<br> arrayname(index1,index2,..)=value<br> arrayname=value1,value2,value3,...<br> arrayname=multiple1*value1,multiple2*value2,...<br></pre>
where multiple is a positive integer number. If you do not define a
variable
the default value is used.
<p>The Fortran 90 standard for logical variable values is either <b>T</b>
and
<b>F</b> or <b>.true.</b> and <b>.false.</b>,
but some compilers accept only one of them. </p>
<p>The default values for the (many) parameters are defined in
the file
<b>amrio.t</b>, specifically in the subroutine <b>readparameters</b>.
</p>
<p>The following namelist examples contain all the possible
variables to set,
choices are indicated by <b>|</b>. The first choice is the
default value.
In an actual file only the parameters different from default need to be
set. Constant names that should be replaced by the actual values are in
capital letters. The <b>...</b> indicates optional extra
elements for
arrays, or extra words in strings. After each namelist a discussion
follows.
</p>
<ol>
<h3><a name="Testlist">Testlist</a></h3>
<pre> &amp;testlist<br>	teststr='SUBROUTINE1 SUBROUTINE2 ... '<br>	ixtest1=INTEGER ixtest2=INTEGER ixtest3=INTEGER<br>	iwtest=INTEGER<br>	idimtest=INTEGER<br>/<br></pre>
Setting <b>teststr</b> causes some information printed to
the standard output from the subroutines listed in <b>teststr</b>.
The output refers to the location set by ixtest1 (ixtest2,ixtest3).
The default value for ixtest1 (ixtest2, ixtest3) is set to 1.
<p>The variable to be tested is iwtest (default 1), and the
direction is idimtest (default 1). To see what output you will get,
please find all occurancies of <b>oktest</b> in the tested
subroutine(s) in the source code.
They only have an effect if written in small case.
You can use these variables to debug your AMRVACUSR subroutines.
<b>This Testlist namelist is a heritage namelist from VAC, and
it is not advisable to use
it when running the code on multiple processors. It is a rather
obsolete feature.</b>
</p>
<h3><a name="Filelist">Filelist</a></h3>
<pre> &amp;filelist<br>	filenameini='unavailable' | 'datamr/FILEINIBASE'<br>	filenameout='datamr/FILEOUTBASE'<br> filenamelog='datamr/FILELOGBASE'<br>	typefilelog='default' | 'special'<br>	snapshotini= INTEGER<br>	snapshotnext= INTEGER<br>	slicenext= INTEGER<br>	firstprocess= F | T<br> changeglobals= F | T<br>	resetgrid= F | T<br> typeparIO= 1 | 0 | -1<br> addmpibarrier= F | T<br>	convert= F | T<br> convert_type= 'idl' | 'tecplot' | 'tecplotCC' | 'vtu' | 'vtuCC' | 'vtuB' | 'vtuBCC' | 'dx' |<br> 'tecplotmpi' | 'tecplotCCmpi' | 'vtumpi' |<br> 'vtuCCmpi' | 'pvtumpi' | 'pvtuCCmpi' | 'tecline' | 'teclinempi' | 'onegrid'<br> autoconvert = F | T<br> sliceascii = F | T<br> saveprim= F | T<br> primnames= ' '<br> nwauxio= INTEGER<br> normvar: an array of size (0:nw) of DOUBLES<br> normt= DOUBLE<br> level_io= INTEGER<br> level_io_min= INTEGER<br> level_io_max= INTEGER<br> nocartesian= F | T<br> uselimiter= F | T <br> dxfiletype = 'lsb' | 'msb'<br> writew= nw logicals, all T by default<br> writelevel= nlevelshi logicals, all T by default<br> writespshift: an array of dimension (1:ndim,1:2), <br> to be filled with DOUBLES (all 0 by default)<br>/<br></pre>
The filenameout, and filenamelog correspond to the basename of the
output and log-file, respectively, and since they have no default
values, they have to be defined.
With the aid of the <b>savelist</b>, you will request to
save individual snapshots in consecutively numbered data files with
names
<b>datamr/FILEOUTBASE0000.dat</b>, <b>datamr/FILEOUTBASE0001.dat</b>,
<b>datamr/FILEOUTBASE0002.dat</b>, etc. The four-digit
number added to the filenameout
will by default start at (the four digit equivalent of) snapshotnext
(i.e. when snapshotnext=4, the first file will have extension
0004.dat). Note that
this means we exclude saving more than 10000 snapshots per run, since
after reaching 9999 the code will start overwriting the snapshot with
0000.dat extension.
Similarly, the <b>slicenext</b> option allows to specify
the index of the next slice output. This parameter thus has to be
adjusted at restart. By default, <b>firstsnapshot=0</b>
and <b>firstslice=0</b>. The logfile name will become <b>datamr/FILELOGBASE.log</b>,
i.e. the code will automatically add the .log extension to the
logfilename. In the logfile, again as often as specified in the <b>savelist</b>,
one can save user-defined information when selecting the
<b>typefilelog='special'</b>. By default, the logfile
contains one line with a string corresponding to the `fileheadout'
given in methodlist (see below), and one line with a string that is
meant to identify the coordinate names, the conserved variables
(wnames) and other entries, and then follows a sequence of lines
containing numbers: i.e. a single line per requested output time,
containing
the integer timestep counter <em>it</em>, the time <em>t</em>,
the time step to be used in the next time advance <em>dt</em>,
the domain integrated value of each conserved variable (<it>nw</it>
real numbers, which allows to check perfect conservation across the
grid tree when the boundary conditions imply it), the percentage of the
domain covered by each allowed grid level (<em>mxnest</em>
real numbers between 0.0 and 1.0, with 1.0 indicating 100% coverage:
when all <em>mxnest</em> numbers are summed, we get 1.0),
and the number of grids per allowed grid level (hence, <em>mxnest</em>
integers).
The logfile is by default saved as an ASCII file. When a residual is
calculated (steady-state computations), the value of the residual is
stored in the logfile, just after the time step <em>dt</em>
en before all domain integrated values.
<p>Normally, there will be no input file, as the code will need
to automatically generate an appropriate grid hierarchy for time <em>t=0</em>.
However, one can restart from any previous <b>datamr/FILEOUTBASE****.dat</b>
file, by setting <b>filenameini='datamr/FILEOUTBASE'</b>,
where you select, e.g. the number 0002 using <b>snapshotini=2</b>.
Accordingly, to prevent
overwriting the earlier snapshots, use then <b>snapshotnext=3</b>
at the same time, so that there is no need to alter the filenameout.
The filenamelog
should best be renamed at restart, though, as otherwise it will be
overwritten. As one may want to read in a previous snapshot, and then
only for this
snapshot change something locally or globally in one or more variables,
the logical <b>firstprocess=T</b> will result in a call to
<em>initonegrid_usr</em>
in your AMRVACUSR subroutine when a restart is performed (i.e. when
filenameini is not 'unavailable', which is its default value). The
logical <b>resetgrid=T</b> will rebuild the AMR grid when
a restart is performed. The logical <b>changeglobals=T</b>
will call initglobal to specify global parameters (e.g. equation
parameters, eqpar(gamma_)) again after reading in data to restarting a
run.
</p>
<p>Normally, the code will do its parallel IO in a manner where
all processors write in parallel to the same single file. On some
systems, this mode of parallel IO is not
available (yet), and we therefore provide an alternative means of
parallel IO where a master-slave process first lets all processors
communicate their data piece to the master,
which consecutively then outputs all data in the single file. This can
be selected by setting <b>typeparIO</b>. Normally the
value 1 is used, while the 0 value does a master-slave parallel IO. The
value -1 does also a master-slave IO, and then uses fortran IO
statements like open, write instead of using the MPI versions
MPI_FILE_WRITE, MPI_FILE_OPEN etc.
</p>
<p>Throughout the code, one can enforce some additional
MPI_BARRIER calls, by setting the variable <b>addmpibarrier=T</b>.
They might slow down execution,
but may help resolve unexpected issues with MPI communication on new
platforms. This option is inactive by default.
</p>
<p>The order of saving snapshots, and regridding actions
through the subroutine <em>resetgridtree</em> is fixed:
regrid happens after the advance by one timestep, then regrid, then
save the data. This has consequences for the optional variables beyond <em>nwflux</em>.
</p>
<p>The code can also be used to postprocess the MPI-AMRVAC .dat
files (which are the only ones to be used for restarts) to some
convenient data
files for later visualisation purposes. Such conversion of a single
.dat file at a time is to be done with the same executable (or at least
one on a possibly
different machine, but with the same setamrvac settings), on a single
processor (i.e. using <em>mpirun -np 1 amrvac</em>). Only
selected output types can be converted in parallel, namely those whose
name contains <em>mpi</em> as part of the <em>convert_type</em>
string. Currently, this includes the ASCII
versions of <em>vtumpi</em> and <em>vtuCCmpi</em>
(corner versus cell center values), and similarly for tecplot (<em>tecplotmpi</em>
or <em>tecplotCCmpi</em>). In addition, <em>pvtumpi</em>
and <em>pvtuCCmpi</em> are possible which will result in a
<em>*.vtu</em> file for each processor. </p>
<p>In this conversion mode,
the idea is to set the filenameini and the snapshotini entries together
with <b>convert=T</b>. You can ask the code during
conversion to change from conservative to primitive variable output by
setting <b>saveprim=T</b>, and then you should give the
corresponding names for the
primitive variables in <b>primnames</b>. Just like <b>wnames</b>
(the latter is defined in the <em>methodlist</em>), this
is a single string with space-seperated
labels for the variables. The <b>primnames</b> just should
list names for the <em>nw</em> primitive variables, like <em>wnames</em>
does for the conservative ones.
It is also possible to perform the conversion step during run of the
simulation with the switch <b>autoconvert=T</b>.
Naturally, this leads to more computational overhead and IO, but using
the <em>pvtu(CC)mpi</em> filetype, this can be reduced to
a minimum. </p>
<p>For simulations on non-cartesian grids (cylindrical or
spherical), there is the option to output the non-cartesian cell
coordinates and vector components, which then forces you typically to
do the conversion to cell center cartesian grid coordinates and vector
variables in your visualization session. By default (i.e. <b>nocartesian=F</b>),
the convert module does the conversion
from the orthogonal to locally cartesian coordinates and vector
components for you. You can overrule this default behavior by setting <b>nocartesian=T</b>.
(note: for tecplot format, the coordinate labels are then corrected in
the converted file as well).
</p>
<p>The only variable that then further matters is <b>convert_type</b>.
Selecting <em>'idl'</em> will generate a corresponding
'datamr/FILEINIBASE****.out' file, which is stored in binary and can be
handled with the Idl macros. For type <em>'tecplot'</em>,
a corresponding 'datamr/FILEINIBASE****.plt'
file will be generated, which is an ASCII file that stores the cell
corner locations and corner values for the conserved variables, to be
handled with Tecplot. The <em>'onegrid'</em> conversion
type is just useful in 1D AMR runs, to generate a single block file
(extension '.blk'). Also particular to 1D data, and for TecPlot
purposes alone, is the <em>'tecline'</em> option. This can
also be done in parallel mode, where it is called 'teclinempi'.
</p>
<p>The type <em>'dx'</em>, will generate a Data
Explorer file 'datamr/FILEINIBASE****.dx', which can be used with the
free DX visualization software (<em>www.opendx.org</em>).
When <b>convert_type='dx'</b>, there is the additional <b>dxfiletype</b>
variable. The dx filetype stores in binary format, and stores cell
center coordinates and values. The binary format for dx files
can differ from machine to machine, but will be one of <em>'lsb'</em>
or <em>'msb'</em> (for last or most significant bit order,
respectively). </p>
<p>For visualization using paraview (<em>www.paraview.org</em>),
the option to convert to <b>convert_type='vtu'</b> can be
used. For both <em>vtu</em> and <em>tecplot</em>
formats, there are also corresponding
<em>vtuCC</em> and <em>tecplotCC</em>
options, which store the data with the actually computed cell-centered
values. For the <em>vtu</em> and <em>tecplot</em>
formats on the
other hand, the code tries to already do some interpolation from cell
center to cell corner variables for you, but this may introduce some
artificial effects in non-cartesian geometries.
The <em>vtuB</em> and <em>vtuBCC</em> do the
same as <em>vtu(CC)</em> but save the data in binary
format.
</p>
<p>It is even possible to temporarily add additionally computed
auxiliary variables that are instantaneously computable from the data
in the <b>datamr/FILEOUTBASE****.dat</b> file to the
converted snapshot. You should then provide the number of such extra
variables in <b>nwauxio</b>
(see also AMRVAC_Man/<a href="mpiamrvac_nw.html">mpiamrvac_nw.html</a>),
and a corresponding definition for how to compute them from the
available <em>nw</em> variables in the subroutine
<em>specialvar_output</em> whose default interface is
provided in the <em>amrvacnul.speciallog.t</em> module.
You can there compute variables that are not in your simulation or data
file, and store them in the extra slots <em>nw+1:nw+nwauxio</em>
of the <em>w</em> variable. For consistency, you should
also then add a meaningfull name to the strings that we use for
identifying variables, namely <em>primnames, wnames</em>.
This has to be done in the subroutine <em>specialvarnames_output</em>.
</p>
<p>The output values are normally given in code units, i.e. in
the dimensionless values used throughout the computation (in the
initial condition, we always
adhere to the good practice of choosing an appropriate unit of length,
time, mass and expressing everything in dimensionless fashion). One
can, in the convert
stage only, ask to multiply the values by their respective dimensional
unit value. <b>normt</b> should then be the unit for time,
while the array
<b>normvar</b> combines the unit of length (to be stored
in <em>normvar(0)</em>) with corresponding units for all
primitive variables in
<em>normvar(1:nw)</em>. The corresponding values for
conservative entries are computed in <em>convert.t</em>
when <em>saveprim=F</em>. Note that these latter are not
all independent and must be set correctly by the user. In any case,
they are not in the
restart files (the ones with <em>.dat</em>), and just used
at conversion stage. See for details of their use the <em>convert.t</em>
module.
</p>
<p>There is a <b>uselimiter</b> logical variable,
which is false by default, but can be used when having a 1D Cartesian
grid computation, where it then influences the way in which the convert
step computes corner values from cell center values. Normally, it would
just take
the arithmetic average as in <em>0.5(w_L+w_R)</em> where <em>w_L</em>
is the cell center value at left, and <em>w_R</em> is at
right. Activating uselimiter will compute <em>0.5(w_LC+w_RC)</em>
instead, where the left and right edge values <em>w_LC, w_RC</em>
are computed by limited
reconstruction first.
</p>
<p>Note that different formats for postprocess data conversion
can be added in the <b>convert.t</b> subroutine.
See AMRVAC_Man/<a href="convert.html">convert</a>
for details.
</p>
<p>The <em>VTK</em>-based formats allow for saving
only a part of the <em>nw</em> variables, by setting the
logical array <b>writew</b>. The same is true for
selecting levels by using the array <b>writelevel</b>.
Finally, you can clip away part of the domain, for output in a selected
region. This is done by filling the array <b>writespshift</b>.
That array should use (consistent) double precision values (between 0
and 1) that specify the percentage of the total domain to be clipped
away from the domain boundary at the minimum side, and from the maximum
side, respectively, and this for all dimensions. The array has thus a
dimensionality <em>(1:ndim,1:2)</em>, with the first entry
specifying the
dimension, and the second whether you clip for minimum (1) and maximum
(2) sides, respectively.
Note that in the end, only the grids that are fully contained within
the clipped region are
then converted and stored in the output.
</p>
<p>The switches <b>level_io</b>, <b>level_io_min</b>
and <b>level_io_max</b>
are there to restrict the AMR levels of the output file at the convert
stage. These switches do not work with autoconvert. E.g. setting <em>level_io=3</em>
will coarsen/refine the data to level 3
everywhere, resulting in a uniform grid. <em>level_io_min</em>
limits the minimum level for output by refining
levels below level_io_min until level_io_min is reached.
Correspondingly, <em>level_io_max</em> limits the maximum
level of the
output file. This can be useful to visualize large datasets. </p>
<h3><a name="Savelist">Savelist</a></h3>
<pre> &amp;savelist<br>	ditsave(FILEINDEX)=INTEGER<br>	dtsave(FILEINDEX)=DOUBLE<br>	itsave(SAVEINDEX,FILEINDEX)=INTEGER<br>	tsave(SAVEINDEX,FILEINDEX)=DOUBLE<br> nslices=INTEGER<br> slicedir(INTEGER)=INTEGER<br> slicecoord(INTEGER)=DOUBLE<br> collapse(INTEGER) = F | T<br> collapseLevel = INTEGER<br>/<br></pre>
You can specify the frequency or the actual times of saving results
into the log, (consecutive) output, slice files, collapsed views and
calls to
the analysis subroutine which are identified by their FILEINDEX 1, 2,
3, 4 and 5 respectively.
The slices are parametrized by values
of <b>nslices</b>, <b>slicedir</b> and <b>slicecoord</b>,
more
information on slice output can be found
in <a href="slices.html">slice output</a>. The
collapse feature is
described in detail in <a href="collapsed.html">collapsed
output</a>
and some info on the analysis feature is given
in <a href="analysis.html">analysis</a>.
<p>The times can be given in timesteps or physical time.
Typical examples: <b>ditsave=1,10</b> saves results into
the log file at every timestep, and will generate a .dat output file
every 10-th step (however, the number at the end of the
'datamr/FILEOUTBASE****.dat' file will increase by one from
firstsnapshot, as explained above). <b>dtsave=0.1,12.5</b>
saves into the log file at times 0.1,0.2,... and will generate a .dat
output file at time 12.5,25,37.5,... , assuming that we start at t=0. <b>ditsave(1)=10
tsave(1,2)=5.2 tsave(2,2)=7.</b>
will save info into the log file every 10-th timestep and snapshots at
t=5.2 and 7. Actually, the first timestep when physical time is greater
than 5.2 (or 7.0) is saved. Mixing itsave and tsave is possible,
mixing dtsave (or ditsave) with tsave (or itsave) for the same file
should be
done with care, since dtsave (and ditsave) will be offset by any
intervening tsave (and itsave). However, one may want to save snapshots
more frequently
at the beginning of the simulation. E.g. <b>tsave(1,2)=0.1
tsave(2,2)=0.25
tsave(3,2)=0.5 dtsave(2)=0.5</b> could be used to save snapshots
at times
0.1, 0.25, 0.5, 1, 1.5, ... etc.
</p>
<p>If no save condition is given for a file you get a warning,
but <em>the final output is always saved</em> after the
stop condition has been
fulfilled. If <b>itsave(1,2)=0</b> is set, the initial
state is saved before advancing. </p>
<h3><a name="Stoplist">Stoplist</a></h3>
<pre> &amp;stoplist<br>	itmax =INTEGER<br>	tmax =DOUBLE<br>	tmaxexact =F | T<br>	dtmin =DOUBLE<br>	it =INTEGER<br>	t =DOUBLE<br>	treset =F | T<br>	itreset =F | T<br>	residmin =DOUBLE<br>	residmax =DOUBLE<br> typeresid = 'relative' | 'absolute'<br>/<br></pre>
You may use an upper limit <b>itmax</b> for the number of
timesteps and/or the physical time, <b>tmax</b>. If <b>tmaxexact=T</b>
is set, the last time step will be reduced so that the final time 't'
is exactly 'tmax'.
<p>Numerical or physical instabilities may produce huge changes
or very small
time steps depending on the way <b>dt</b> is determined.
These breakdowns
can be controlled by either setting a lower limit <b>dtmin</b>
for the physical time step, which is useful when <b>dt</b>
is determined from the <b>courantpar</b> parameter.
If AMRVAC stops due to <b>dt &lt; dtmin</b>, a warning
message is printed.
</p>
<p>You have to specify at least one of <b>tmax, itmax</b>.
AMRVAC stops execution when any of the limits are exceeded. The initial
time value <b>t</b> and integer time step counter <b>it</b>
values can be specified here. However, when a restart is performed from
a previous .dat file, the values in that file
will be used unless you enforce their reset to the values specified
here by activating the logicals <b>treset=T</b>, or <b>itreset=T</b>.
</p>
<p>In case the code is used for computing towards a
steady-state, it is useful to quantify the evolution of the residual as
a function of time.
The residual will be computed taking account of all <em>nwflux</em>
variables
(see also AMRVAC_Man/<a href="mpiamrvac_nw.html">mpiamrvac_nw.html</a>),
over all grids. You can tell the code to stop computing
when a preset minimal value for this residual is reached, by specifying
<b>residmin=1.0d-6</b> (for example, a rather stringent
value when
all variables are taken into account). Similarly, setting <b>residmax=1.0d8</b>
will force the code to stop when the residual change
becomes excessively large (indicating that you will not reach a steady
state for the problem at hand then, without explaining you why).
The residual is computed as specified in the subroutine <em>getresidual</em>
in the <em>setdt.t</em> module, and you may want to
inspect what it actually computes there (and perhaps modify it for your
purposes), and see the distinction between
<em>typeresid='relative'</em> or <em>typeresid='absolute'</em>.
When either residmin or residmax is specified here, the value of the
residual will be added to the logfile.
</p>
<h3><a name="Methodlist">Methodlist</a></h3>
<pre>&amp;methodlist<br><br><a href="#wnames">wnames=</a>	'STRING'<br>fileheadout= 'STRING'<br><br><a href="#typeadvance">typeadvance</a>='twostep' | 'onestep' | 'threestep' | 'rk4' | 'fourstep' | 'ssprk43' | 'ssprk54'<br>typefull1=nlevelshi strings from: 'tvdlf','hll','hllc','hllcd','tvdmu','tvd','cd','fd','hll1','hllc1','hllcd1','tvd1','tvdlf1','tvdmu1','source','nul'<br>typepred1=nlevelshi strings from: 'default','hancock','tvdlf','hll','hllc','tvdmu','cd','fd','nul'<br>typelow1= nlevelshi strings from: 'default' | 'tvdlf1' | 'hll1' | 'hllc1' | 'hllcd1' | 'tvdmu1' | 'tvd1' | 'cd' | 'fd'<br><br><a href="#typelimiter">typelimiter1</a>= nlevelshi strings from: 'minmod' | 'woodward' | 'superbee' | 'vanleer' | 'albada' | 'ppm' | 'mcbeta' | 'koren' | 'cada' | 'cada3' | 'mp5'<br>typegradlimiter1= nlevelshi strings from: 'minmod' | 'woodward' | 'superbee' | 'vanleer' | 'albada' | 'ppm' | 'mcbeta' | 'koren' | 'cada' | 'cada3'<br>typelimited='original' | 'previous' | 'predictor'<br>useprimitive= T | F<br>loglimit= nw logicals, all false by default<br>flatsh = F | T<br>flatcd = F | T<br>flatppm= T | F<br>mcbeta= DOUBLE<br><br><a href="#typeentropy">typeentropy</a>= 'nul','powell','harten','ratio','yee' <br>entropycoef= DOUBLE, DOUBLE, DOUBLE, ....<br><br><a href="#typetvd">typetvd</a>= 'roe' | 'yee' | 'harten' | 'sweby' <br>typeaverage='default' | 'roe' | 'arithmetic'<br><br><a href="#typetvd">typetvdlf</a>= 'cmaxmean' | 'other'<br>tvdlfeps = DOUBLE<br>BnormLF = T | F<br><br><a href="#typetvd">flathllc</a>= F | T <br>nxdiffusehllc = INTEGER<br><br><a href="#typeaxial">typeaxial</a>= 'slab' | 'cylindrical' | 'spherical' <br>typespherical= 1 | 0<br>usecovariant= F | T<br><br><a href="#ssplitdivb">ssplitdivb</a>= F | T<br><a href="#ssplitdust">ssplitdust</a>= F | T<br><a href="#ssplitresis">ssplitresis</a>= F | T<br><a href="#ssplituser">ssplituser</a>= F | T<br>typesourcesplit= 'sfs' | 'sf' | 'ssfss' | 'ssf'<br>dimsplit= F | T<br>typedimsplit= 'default' | 'xyyx'| 'xy'<br><br><a href="#smallrho">smallrho</a>= DOUBLE<br>smallp= DOUBLE<br>fixsmall= T | F<br>strictsmall= T | F<br>strictgetaux= F | T<br>nflatgetaux=1<br>fixprocess= F | T<br><br><a href="#typedivbfix">typedivbfix</a>= 'powel' | 'janhunen' | 'linde' | 'glm1' | 'glm2' | 'glm3'<br>divbwave= T | F<br>divbdiff= DOUBLE<br>typedivbdiff= 'all' | 'ind'<br>B0field= F | T<br>Bdip= DOUBLE<br>Bquad= DOUBLE<br>Boct= DOUBLE<br>Busr= DOUBLE<br>compactres= F | T<br>typegrad = 'central' | 'limited'<br>typediv = 'central' | 'limited'<br><br><a href="#relatmhd">useprimitiveRel</a>= T | F<br>maxitnr= INTEGER<br>tolernr= DOUBLE<br>absaccnr= DOUBLE<br>dmaxvel= DOUBLE<br>typepoly= 'meliani' | 'bergmans' | 'original' | 'gammie'<br>strictnr= T | F<br>strictzero= T | F<br><br><a href="#cool">ncool</a>= INTEGER<br>cmulti = INTEGER<br>coolmethod= ' '<br>coolcurve= ' '<br>Tfix= F | T<br><br><a href="#ptmass">ptmass</a>= DOUBLE<br>x1ptms= DOUBLE<br>x2ptms= DOUBLE<br>x3ptms= DOUBLE<br><br><a href="#dustmethod" l="">dustmethod</a>= 'Kwok','sticking','linear','none'<br>dustzero = T|F<br>dustspecies = 'graphite','silicate'<br>dusttemp = 'constant','ism','stellar'<br>smallrhod = DOUBLE'<br><br>/<br></pre>
<ol>
<h4><a name="wnames">wnames</a>,
fileheadout</h4>
<b>wnames</b> is a string of (conserved) variable
names, which is only stored for use in the input and output data files.
The <b>wnames</b> string of variable names is used in the
default log file header, and should be e.g. 'rho m1 m2 e b1 b2' for MHD
with 2 vector components. These labels are the ones passed on when
doing the conversion step for tecplot, vtu formats.
<p><b>fileheadout</b> is the header line in the
output file, and is an identifyer used in the (converted) data files.
Both wnames and fileheadout are thus only relevant within amrio.t and
convert.t, and only have effect for the later data visualization (e.g.
when fileheadout='test_mhd22' is specified, the Idl macros will deduce
from the name that it is for a 2D MHD run).
</p>
<p></p>
<h4><a name="typeadvance">typeadvance</a>,
typefull1, typepred1, typelow1 </h4>
The <b>typeadvance</b> variable determines the time
integration procedure.
The default procedure is a second order predictor-corrector type
'twostep'
scheme (suitable for TVDLF, TVD-MUSCL schemes), and a simple 'onestep'
algorithm for the temporally second order TVD method, or the first
order TVDLF1, TVDMU1, TVD1 schemes. <b>It is not possible to mix
different step size methods across the AMR grid levels.</b>
The temporally first order but spatially second order TVD1 algorithm
is best suited for steady state calculations as
a 'onestep' scheme. The TVDLF and TVD-MUSCL schemes can be forced
to be first order, and linear in the time step, which is good for
getting a steady state, by setting <b>typeadvance='onestep'</b>.
<p>There is also a fourth order Runge-Kutta type method, when
<b>typeadvance='fourstep'</b>. It can be used with <em>dimsplit=.true.</em>
and <em>typelimited='original'</em>. These higher order
time integration methods can be most useful in conjunction with higher
order spatial
discretizations like a fourth order central difference scheme
(currently not implemented).
See also AMRVAC_Man/<a href="discretization.html#Methods">discretization</a>.
</p>
<p>The array <b>typefull1</b> defines a spatial
discretization <a href="methods.html">method</a>
used for the time integration per activated grid level (and on each
level, all variables use the same
discretization). In total, <em>nlevelshi</em> methods must
be specified, by default <em>nlevelshi=8</em> and these
are then all set by <em>typefull1=8*'tvdlf'</em>.
Different discretizations
can be mixed across the <em>mxnest</em> activated grid
levels (but the same stepping scheme
must apply for all of the schemes).
</p>
<p>Setting for a certain level the typefull1 to 'nul' implies
doing no advance at all, and
'source' merely adds sources. These latter two values must be used with
care, obviously,
and are only useful for testing source terms or to save computations
when fluxes are known to be zero.
</p>
<p>The <b>typepred1</b> array is only used when <b>typeadvance='twostep'</b>
and specifies
the predictor step discretization, again per level (so <em>nlevelshi</em>
strings must be set).
By default, it contains <em>typepred1=8*'default'</em>
(default value <em>nlevelshi=8</em>), and it then deduces
e.g. that 'cd' is predictor for 'cd', 'hancock' is predictor for both
'tvdlf' and 'tvdmu'. Check its default behavior in the <em>amrio.t</em>
module.
Thus <b>typepred1</b> need not be defined in most cases,
however <b>typefull1</b> should always be defined if
methods other than 'tvdlf' are to be used. </p>
<p>The <b>typelow1</b> is only used when the AMR
strategy is based on Richardson extrapolation. It then specifies the
first order scheme used in this process, to be done per level.
By default, <b>typelow1=nlevelshi*'default'</b> will imply
the use of <b>'tvdlf1'</b> for all methods,
except for 'cd' where it is 'cd'. It is the same low order scheme that
is then used in the Richardson process across the entire grid
hierarchy, and is decided on the basis of the typefull1(l) for level l
in amrio.t.
</p>
<p></p>
<h4><a name="typelimiter">typelimiter1</a>,
typegradlimiter1, typelimited, useprimitive, loglimit, flatcd, flatsh,
flatppm</h4>
For the TVDLF and TVD-MUSCL methods different limiter functions can be
defined for the limited linear reconstructions from cell-center to
cell-edge variables, and for the TVD method, for the characteristic
variables. See the <b>src/amrvacpar.t</b> file for the
order of the characteristic variables.
The default limiter is the most diffusive <b>typelimiter1=nlevelshi*'minmod'</b>
limiter (minmod for all levels), but one can also use <b>typelimiter1=nlevelshi*'woodward'</b>,
or use different limiters per level.
<p>The <b>typegradlimiter1</b> is the selection
of a limiter to be used in computing gradients (or divergence of
vector)
when the typegrad=limited (or typediv=limited) is selected. It is thus
only used in the gradientS (divvectorS) subroutines
in geometry.t (and has effect for the MHD modules).
</p>
<p>The <b>typelimited</b> variable tells the TVD
type methods what should be used
as a basis for the limiting. By default, the <b>original</b>
value is used in 1D and for dimensional splitting, while for
dimensionally unsplit multidimensional case (dimsplit=F), TVDLF and
TVD-MUSCL uses the <b>previous</b> value from <b>wold</b>
for limiting. </p>
<p>The <b>useprimitive</b> variable decides
whether TVDLF and TVDMUSCL schemes
should limit the slopes of the <em>primitive</em> or <em>conservative</em>
variables. The default behaviour is limiting the primitive variables.
For the onestep TVD scheme the 'useprimitive'
parameter determines how the pressure jump is calculated in the
approximate Riemann solver. For the false value the jump is calculated
from the jumps in the conservative variables following strictly the TVD
algorithm, while for the default true value the jump is approximated by
the pressure difference, which is simpler and slightly faster. This
subtle change does not
seem to influence the results obtained by the TVD scheme significantly.
</p>
<p>The use of <b>useprimitive=T</b> can be
combined with the selection of logarithmic transformation on (positive)
variables.
I.e., when e.g. having a gravitational stratification, one might
benefit from performing linear reconstruction on the primitive
variables log10(rho) and/or log10(p). This can be done by setting the
corresponding <em>loglimit(iw)=T</em> with <em>iw</em>
the
label of the corresponding component in the <em>w</em>
array (for density, this is thus <em>iw=1</em>).
</p>
<p>When using PPM as a limiter, minor differences can be
obtained using the switches flatppm, flatcd, flatsh. The last two
are meant to minimize potential ripples around contact discontuinities
(flatcd) or shocks (flatsh), but one should first try
without these flattenings (default behavior). PPM is actually only used
in a quadratic reconstruction from center to edge,
requires the use of a larger stencil (dixB=4), and can be used either
in the methods (by setting typelimiter1) or in the
gradientS/divvectorS routines (when typegrad or typediv is limited, and
typegradlimiter1 is ppm). The latter is encoded
in geometry.t.
</p>
<p></p>
<h4><a name="typeentropy">typeentropy</a>,
entropycoef</h4>
For Riemann solver based methods, such as TVD and TVD-MUSCL (but not
TVDLF), an entropyfix may be applied to avoid unphysical solutions. The
fix is applied to the characteristic variables, their order
is defined in <b>src/amrvacpar.t</b>. The default entropy
fix is <b>'nul'</b>, i.e. no entropy fix. When an
expansion shock is formed, the entropy fix
should be applied to the non-degenerate characteristic waves, i.e.
waves that can form shocks (sound waves, fast and slow magnetosonic
waves).
The most powerful entropy fix is called 'powell'. In practice, one may
apply an entropy fix to all characteristic waves, usually the slight
extra
diffusion makes the schemes more robust. For Yee's entropyfix the
minimum characteristic speed (normalized by dt/dx) can be set for
each characteristic wave using the <b>entropycoef</b>
array.
<h4><a name="typetvd">typetvd</a>,
typetvdlf, tvdlfeps, typeaverage, BnormLF, flathllc, nxdiffusehllc</h4>
Both <b>tvd</b> and <b>tvdlf</b> have a few
variants, these can be set in the strings <b>typetvd</b>
and <b>typetvdlf</b>, with defaults 'roe' and 'cmaxmean',
respectively. The default <b>typetvd='roe'</b> is the
fastest of the four upwind types. For the TVDLF, the 'cmaxmean' merely
means whether the maximal physical propagation speed is determined as
the maximum speed for the mean state based on averaging left centered
and right centered states, or by taking the maximum physical speed
among both deduced from left and right centered states (the latter is
the
Local Lax-Friedrichs variant). In the TVDLF flux, the diffuse flux part
has a coefficient <b>tvdlfeps</b> which is 1 by default.
For steady-state
computations, one may gain in shock sharpness by reducing this factor
to a positive value smaller than 1.
<p><em>Only for the adiabatic hydro module</em>,
the option to select an arithmetic, or a roe average is available for
use in the roe solver. This is set by the
<b>typeaverage</b>.
</p>
<p>Just like in the TVDLF method, the slightly more involved
HLL
method has a diffuse flux part with coefficient <b>tvdlfeps</b>
which is 1 by default. For steady-state
computations, one may gain in shock sharpness by reducing this factor
to a positive value smaller than 1.
</p>
<p>For calculations involving magnetic fields (variable b0_
is positive), <b>BnormLF=T</b> actually uses the
Lax-Friedrichs flux expression for the normal magnetic field component
in HLL and HLCC methods. This improves robustness.
</p>
<p>When using the HLLC scheme variants, for HD, MHD, SRHD and
SRMHD there is an optional additional flattening in case the
characteristic speed at the contact
is near zero. This is activated by setting <b>flathllc=T</b>
(its default is false). One can also solve some potential noise
problems in the HLLC by swithcing to the HLLCD variant, a kind of mix
between HLLC and TVDLF. The TVDLF is then used in a user-controlled
region around a point where there is a sign change in flux, whose width
is set by <b>nxdiffusehllc</b> (an integer which is 0 by
default).
</p>
<h4><a name="typeaxial">typeaxial</a>,
typespherical, usecovariant</h4>
<b>typeaxial</b> defines the type of curvilinear grid.
For cylindrical coordinate systems, the <em>-phi=</em> and
<em>-z=</em> flags have a meaning and should be used at
<em>$AMRVAC_DIR/setup.pl</em>, to denote the order of
the second and third coordinate. Together, they control
the addition of the geometrical source terms as implemented in the
various physics modules in
the subroutine <em>addgeometry</em>. By default, <b>typeaxial='slab'</b>
and Cartesian coordinates are used (with translational symmetry for
ignorable directions).
<p>In 1D where <em>-d=11</em> we have 1
coordinate with one vector component, and for cylindrical or spherical
cases, the coordinate is the radial cylindrical or spherical distance,
respectively, with
corresponding radial vector component. For <em>-d=12</em>
and <b>typeaxial='cylindrical'</b>,
the second vector component can be either the phi or the z component,
depending on the -phi and
-z flags. For <em>-d=12</em> and <b>typeaxial='spherical'</b>,
the second vector component is
always the theta component. Similarly for <em>-d=13</em>,
only the cylindrical case has a choice for the order of the vector
components. Not all combinations make sense, though.
</p>
<p>In 2D 'slab' means translational symmetry when performing
2.5D simulations (i.e. <em>$AMRVAC_DIR/setup.pl -d=23</em>).
</p>
<p>For 2D and 'cylindrical' (which can be 2D or 2.5D) the
grid and the symmetry depend on the settings for the -phi and -z flags.
When -d=22 -z=2, a cartesian grid is used in a poloidal plane, with
axial symmetry for the r- and z- vector components. The same is true
for -d=23 -z=2 -phi=3, when all three vector components are then
depending on (r,z) coordinates only. The vector components then appear
in the r,z,phi order.
One can use 2.5D on a circular grid also with translational symmetry in
the third, i.e. axial, direction by the use of <em>$AMRVAC_DIR/setup.pl
-d=23 -phi=2 -z=3</em>. The vector components then appear in the
r,phi,z order.
</p>
<p>For 2D and 'spherical', the coordinates denote radial and
polar angle in a poloidal plane, and similarly for 2.5D in combination
with spherical where the third vector component is then the
phi- component, depending on (r,theta) alone. This means that 2D and
'spherical' implies the use of a polar grid in a poloidal cross-section
(i.e. one containing the symmetry axis) and axial symmetry for 2.5D
runs. </p>
<p>In 3D the choice of
curvilinear grid is Cartesian for 'slab', and the usual Cylindrical and
Spherical coordinate
systems when setting one of those latter values. Note that vector
components are to be interpreted in the corresponding coordinate
system!
</p>
<p>Please read <b>AMRVAC_Man/<a href="axial.html">axial</a></b>
before you try to
do simulations in non-slab symmetry.
</p>
<p>In case you select <b>typeaxial='spherical'</b>,
the geometrical info is filled in a slightly different way depending on
the integer <em>typespherical</em>. See the details in <em>geometry.t</em>
module.
</p>
<p>The <em>usecovariant</em> option is as yet
inactive, but is meant to prepare for general relativistic modules,
and/or an alternative means to handle
non-cartesian geometries.
</p>
<h4><a name="ssplitdivb">ssplitdivb</a>,
ssplitdust,ssplitresis,ssplituser, typesourcesplit, dimsplit,
typedimsplit</h4>
The sources, if any, can be added in a split or unsplit way according
to the logical variables <b>ssplitdivb</b>, <b>ssplitdust</b>,
<b>ssplitresis</b>, and <b>ssplituser</b>
which correspond to divb source to maintain divergence free of magnetic
field, dust effect, resistivity, and other sources added by user,
respectively. Their default values are false meaning these sources are
added in a unplit way by default.
The split sources are added according to <b>typesourcesplit</b>.
The meaning of the different options for <b>typesourcesplit</b>
is described in AMRVAC_Man/<a href="discretization.html#Splitting">discretization</a>.
Under default settings, we use unsplit sources only, and if one reverts
to split sources, <b>typesourcesplit='sfs'</b>.
<p>In multidimensional calculations dimensional splitting can
be used by
setting <b>dimsplit=T</b>, with an alternating order of
the sweeps <b>typedimsplit='xyyx'</b>
by default. For AMRVAC simulations, it is best to use <b>dimsplit=F</b>,
the default value,
but the TVD method needs a dimensionally split strategy.
The limitations on using dimensionally unsplit methods are described in
AMRVAC_Man/<a href="methods.html">methods</a>.
</p>
<h4><a name="smallrho">smallrho</a>,
smallp, fixprocess, fixsmall, strictsmall, strictgetaux, nflatgetaux</h4>
Negative pressure or density caused by the numerical approximations can
make the code crash.
For HD, MHD and all SRHD and SRMHD variants, this can be monitored or
even cured by the <b>smallvalues</b> subroutines in <b>src/amrvacphys.correctaux**.t</b>
modules, where ** denotes the physics (hd, mhd, srhd, srmhd). This
monitoring is active whenever <b>fixsmall=T</b>, its
default setting (hence, you can avoid all checks, but also all cures,
by setting <b>fixsmall=F</b>).
The control parameters <b>smallrho, smallp</b> play a role
here: they can be set to small positive values, while their default is <b>smallrho=-1.0d0</b>
and
<b>smallp=-1.0d0</b>, i.e. no replacements at all. They
take effect for HD, MHD, SRHD and SRMHD
equations when set to a small value, e.g. <b>smallp=1.0d-12</b>.
Actually, they in turn determine <em>minp, minrho, smalle</em>
for HD and MHD modules (as set in the <b>initglobaldata</b>
subroutine in the physics module) and <em>minp, minrho,
smalltau, smallxi</em> for the relativistic variants.
These latter quantities appear in the <b>src/amrvacphys.correctaux**.t</b>
modules.
<p>The actual treatment involves the <em>strictsmall</em>
parameter: Its default value (T) causes a full stop when the
smallvalues subroutine in the physics
modules would normally correct small densities or energies by some
artificial vacuum prescription. This corrective prescription is thus
turned off by default.
In this way, you can use it for debugging purposes, to spot from where
the actual negative and unphysical value gets introduced. If it is
somehow unavoidable in your simulations, then you may rerun with a
recovery process truned on as follows.
When setting <em>strictsmall=F</em>, two kinds of recovery
procedures can be selected, controlled by the logical <em>strictgetaux</em>.
When <em>strictgetaux=T</em>, the parameters smallp,
smallrho (and derived values minrho, minp, smalle, smalltau, smallxi)
are used in an ad-hoc prescription for dealing with `vacuum', as
encoded in <b>src/amrvacphys.correctaux**.t</b>. In case
you select <em>strictgetaux=F</em>, the subroutine
<em>correctaux</em> is used instead, which uses some
kind of averaging from
a user-controlled environment about the faulty cells. The width of this
environment is set by the integer <em>nflatgetaux</em>.
</p>
<p>Setting <b>fixprocess=T</b> results in a call
to the process subroutine before the writing of a snapshot, and
following the determination
of the timestep constraint by means of CFL and other restrictions. It
then interfaces to the <em>process_grid_usr</em>
subroutine whose
default interface is found in <em>amrvacnul.speciallog.t</em>.
You can use this routine for doing computations of non-local auxiliary
variables (like
the divergence of some vector fields, etc),
then using these in turn to do particle acceleration treatments (the
latter to be implemented in the process subroutine, using MPI!), etc.
</p>
<h4><a name="typedivbfix">typedivbfix</a>,
divbwave, divbdiff, typedivbdiff, B0field, Bdip, Bquad, Boct, Busr,
compactres, typegrad, typediv</h4>
Depending on <b>typedivbfix</b>, sources proportionate to
the numerical monopole
errors are added to momemtum, energy, and induction equation (the
'powel' type), or to the induction equation
alone (the 'janhunen' type). The latter type can also be used for SRMHD
cases.
The <b>divbwave</b> switch is effective for the Riemann
type solvers for multi-D MHD only. The default true value corresponds
to Powell's
<i>divergence wave</i> which stabilizes the Riemann
solver. Naturally, if Powell's source terms are to be added and in
practice it is best to
keep the sources out of the Richardson type error estimator (when
used), so that we advocate
<b>ssplitdivb=T</b>.
<p>Another source term strategy for monopole error control is
to do parabolic cleaning,
i.e. add source terms which diffuse the local error at the maximal rate
still compliant with the
CFL limit on the time step. This is activated when <b>divbdiff</b>
is set to a positive number, which should be less than 2, and again
comes in various flavors depending on which equations receive
source terms. The choice where only the induction equation gets
modified, i.e. <b>typedivbdiff='ind'</b> can again be used
for both MHD and SRMHD, and is advocated.
</p>
<p>For MHD, we implemented the possibility to use a splitting
strategy following Tanaka, where a
time-invariant, potential background magnetic field is handled exactly,
so that one solves
for perturbed magnetic field components instead. This field is taken
into account when
<b>B0field=T</b>, and the magnitude of this field is
controlled using the variables <b>Bdip, Bquad, Boct, Busr</b>.
The first three are pre-implemented formulae for a dipole, quadrupole
and octupole field in spherical coordinates only (the parameters set
the strength of the dipole, quadrupole and octupole field). This is
coded up in the module <em>set_B0.t</em>. This same module
calls in addition the <em>specialset_B0</em> subroutine
when <b>Busr</b> is non-zero, where it then should be used
to quantify an additional potential, time-independent field. This
latter can be used for cartesian or cylindrical coordinates as well.
This splitting
strategy can be extended to linear force-free background field with
non-zero current by adding
a source term, namely, perturbed magnetic field cross velocity then dot
background current, in the right hand side of the conservative energy
equation as a user's unsplit special source .
</p>
<p>Resistive source terms for MHD can use a compact
non-conservative formulation of resistive source terms, by setting
compactres=T.
The default <b>compactres=F</b> setting is normally
preferred.
</p>
<p>The <b>typegrad</b> can be selected to switch
from simple centered differencing on the cell center values, to limited
reconstruction followed by
differencing when computing gradients. They call either of <em>gradient</em>
('central') or <em>gradientS</em> ('limited') subroutines
that are themselves found in the
<em>geometry.t</em> module. Similarly, a switch for the
divergene of a vector is the <b>typediv</b> switch. These
are as yet only used in the MHD
modules (classical and relativistic). When the 'limited' variant is
used, one must set the corresponding typegradlimiter1
array to select a limiter (per level).
</p>
<h4><a name="relatmhd">useprimitiveRel</a>,
maxitnr, tolernr, absaccnr, dmaxvel, typepoly, strictnr, strictzero</h4>
For the SRHD and SRMHD modules only. The <b>useprimitiveRel=T</b>
will ensure that in combination
with useprimitive, limited linear reconstruction is done on the spatial
four-velocity
instead of the velocity. It is the default value. The special
relativistic modules
involve a Newton-Raphson procedure for switching from conservative to
primitive,
and the maximum number of NR iterates is set to a default value <b>maxitnr=100</b>.
This newton raphson has a tolerance parameter and absolute accuracy
parameter, by default set to <em>tolernr=1.0d-13</em> and <em>absaccnr=1.0d-13</em>.
These can be changed if needed. The logical <em>strictnr</em>
(T by default) will cause the code to stop when there is an error
related to this
NR procedure. See the detailed implementation in the <em>amrvacphys.t.sr(m)hd(eos)</em>
modules.
<p>For the relativistic MHD modules, an additional parameter
is the <em>strictzero=.true.</em> parameter: it sets the
limit for zero flow conditions as measured by S.S (or even B.B) in the
NR procedure to zero (T) or smalldouble*smalldouble (F).
Further, the <b>dmaxvel=1.0d-8</b> default value is used
in the process to define
a maximal velocity allowed, namely 1-dmaxvel (where velocities are
always below 1,
which is the speed of light value).
For SRMHD, the <b>typepoly</b> determines which
formulation is used for the quartic polynomial
whose zeros determine the forward and backward slow and fast signal
speeds.
</p>
<h4><a name="cool">ncool</a>, cmulti,
coolmethod, coolcurve, Tfix</h4>
These are only used in combination with a cooling module for HD and
MHD, as developed by AJ van Marle,
described in AMRVAC_Man/<a href="mpiamrvac_radcool.html">mpiamrvac_radcool.html</a>.
<h4><a name="ptmass">ptmass</a>,
x1ptms,x2ptms,x3ptms</h4>
These are only used in combination with an optional point gravity module
for HD and MHD, as developed by AJ van Marle,
described in AMRVAC_Man/<a href="mpiamrvac_pointgrav.html">mpiamrvac_pointgrav.html</a>.
<h4><a name="dustmethod">dustmethod</a>,
dustzero,dustspecies,dusttemp,smallrhod </h4>
These are only used when one or more dustspecies is used for HD.
</ol>
<h3><a name="Boundlist">Boundlist</a></h3>
<pre> &amp;boundlist<br> dixB= INTEGER<br>	typeB= 'cont','symm','asymm','periodic','special','noinflow','limitinflow'<br> ratebdflux = DOUBLE<br> internalboundary = F | T<br>	typeghostfill= 'linear' | 'copy' | 'unlimit'<br>	typegridfill= 'linear' | 'other'<br>/<br></pre>
The boundary types have to be defined for each conserved variable at
each physical edge of the grid, i.e.
for 2D hydrodynamics they are in the order:
rho,m1,m2,e at the left boundary; rho,m1,m2,e at the right;
rho,m1,m2,e at the bottom; finally rho,m1,m2,e at the top boundary. In
general, the order is xmin, xmax, ymin, ymax, zmin, and zmax.
<p>The default number of ghost cell layers used to surround the
grid (and in fact each grid at each level and
location) is set by default to <b>dixB=2</b>. If needed,
this value can be increased.
</p>
<p>The default boundary type is <b>cont</b> for
all variables and edges, it means that the gradient (of the
conservative variables) is kept zero by copying the variable values
from the edge of the mesh into the ghost cells. </p>
<p>Other predefined types are
the <b>symm</b> and <b>asymm</b> types, which
are mostly used for reflective boundaries, or at symmetry axes of the
domain (the polar or equatorial axis, e.g.). One then typically makes
the momentum orthogonal to the given boundary antisymmetric (<b>asymm</b>),
the rest of the variables <b>symm</b>.
These boundary types can also be used to represent
a perfectly conducting wall (the orthogonal component of the magnetic
field
should be antisymmetric, the transverse component symmetric) or the
physical symmetry of the physical problem.
</p>
<p>The case of periodic boundaries can be handled with setting
'periodic' for all variables at both boundaries that make up a periodic
pair. Hence triple periodic in 3D MHD where 8 variables are at play
means setting <em>typeB=8*'periodic',8*'periodic',8*'periodic',8*'periodic',8*'periodic',8*'periodic</em>.
For 3D cylindrical and spherical grid computations, the singular polar
axis is trivially handled using a so-called
pi-periodic boundary treatment, where periodicity across the pole comes
from the grid cell diagonally across
the pole, i.e. displaced over pi instead of 2 pi. These are
automatically recognized from the typeaxial setting, and
the corresponding range in angle phi must span 2 pi for cylindrical,
and theta must then start at zero (to include the north pole) and/or
end at pi (for the south pole)
for spherical grids. The user just needs to
set the typeB as if the singular axis is a symmetry boundary (using
symm and asymm combinations).
</p>
<p>The possibility exists to put a boundary condition mimicking
zero or reduced inflow across the computational boundary, by selecting
<em>typeB='noinflow'</em> or <em>typeB='limitinflow'</em>
for the momentum vector components of your particular application. This
is in principle only
relevant for the momentum component locally perpendicular to the
boundary (for others a continuous extrapolation is done).
The <em>noinflow, limitinflow</em> extrapolates values
that are
outwardly moving continuously, while clipping all values that are
inwardly advecting momentum to zero (noinflow) or to a user-controlled
fraction of the inward momentum (limitinflow). The latter fraction is
set by <em>ratebdflux</em> which is 1 by default, and
should be set to a value between zero
and 1 accordingly.
</p>
<p>The <b>special</b> type is to be used for
setting fixed values, or any time dependent or other more complicated
boundary conditions, and results in a call to the <b>specialbound_usr</b>
subroutine which has to be provided by the user in the <a href="amrvacusr.html#Specialbound">AMRVACUSR module</a>.
The variables with <b>special</b> boundary type are
updated last within a given boundary region, thus the subroutine may
use the updated
values of the other variables. The order of the variables is fixed by
the equation module chosen, i.e. <em>rho m1 m2 m3
e b1 b2 b3</em> for 3D MHD, but by setting all typeB entries for
a certain boundary region to special, one is of course entirely free to
fill the boundary info in a user-defined manner.
</p>
<p>Internal boundaries can be used to overwrite the domain
variables with specified values. This is activated with the switch <b>internalboundary=T</b>.
Internally, these are assigned before the ghost-cells and external
boundaries are applied (in subroutine routine get_bc). The user can
provide conditions on the conserved variables depending on location or
time in the subroutine bc_int which is defaulted in
amrvacnul.specialbound.t.
</p>
<p>The <b>typeghostfill='linear'</b> implies the
use of limited linear reconstructions in the filling of ghost cells for
internal boundaries that exist due to the AMR hierarchy. A first order
'copy' can be used as well, or an unlimited linear reconstruction by
setting it to 'unlimit'. To retain second order accuracy, at least the
default 'linear' type is needed.
</p>
<p>The <b>typegridfill='linear'</b> implies the
use of limited linear reconstructions when filling newly triggered,
finer grids from previous coarser grid values. Setting it different
from this default string will imply mere first order copying
for finer level grids (and is thus not advised when second order is
desired).
</p>
<h3><a name="Amrlist">Amrlist</a></h3>
<pre> &amp;amrlist<br>	mxnest= INTEGER<br>	nxlone1= INTEGER<br>	nxlone2= INTEGER<br>	nxlone3= INTEGER<br>	dxlone1= DOUBLE<br>	dxlone2= DOUBLE<br>	dxlone3= DOUBLE<br> xprobmin1= DOUBLE<br> xprobmax1= DOUBLE<br> xprobmin2= DOUBLE<br> xprobmax2= DOUBLE<br> xprobmin3= DOUBLE<br> xprobmax3= DOUBLE<br> errorestimate= INTEGER<br>	nbufferx1= INTEGER<br>	nbufferx2= INTEGER<br>	nbufferx3= INTEGER<br> skipfinestep= F | T<br> amr_wavefilter= nlevelshi DOUBLE values<br> tol= nlevelshi DOUBLE values<br> tolratio= nlevelshi DOUBLE values<br> flags= INTEGER array, with at most nw+1 entries<br> wflags= DOUBLE array, with at most nw values that must sum up to 1.0d0 <br> logflag= nw logical values, all F by default<br> iprob= INTEGER<br> prolongprimitive= F | T<br> coarsenprimitive= F | T<br> restrictprimitive= F | T<br> amrentropy= F | T<br> typeprolonglimit= 'default' | 'minmod' | 'woodward' | 'mcbeta' | 'koren'<br> tfixgrid= DOUBLE<br> itfixgrid= INTEGER<br> ditregrid= INTEGER<br>/<br></pre>
<ol>
<h4>mxnest, nxlone^D, dxlone^D, xprob^L</h4>
<b>mxnest</b> indicates the maximum number of grid
levels that can be used during the simulation, including the base grid
level. It is an integer value which is maximally equal to the parameter
<em>nlevelshi</em> and minimally equal to 1 (which is
the default value implying no refinement at all, but possibly a domain
decomposition when the domain resolution is a multiple of the maximal
grid resolution controlled by the -g= flag of $AMRVAC_DIR/setup.pl).
The parameter <em>nlevelshi=8</em> by default, a value set
in <em>mod_indices.t</em>, so that if more than 8 levels
are to be used, one must change this value and recompile.
Note that when <em>mxnest&gt;1</em>, it is possible
that during runtime, the highest grid level is temporarily lower than
mxnest, and/or that the coarsest grid is at a higher level than the
base level.
<p>The computational domain is set by specifying the minimal
and maximal coordinate value per direction in the <em>xprob^L</em>
settings. When cylindrical or spherical coordinates are selected with
typexial, the angle ranges (for phi in the cylindrical case, and for
both theta and phi in the spherical case) are to be given in 2 pi
units. </p>
<p>The base grid resolution (i.e. on the coarsest level 1) is
best specified by providing the number of grid cells per dimension to
cover the full computational domain set by the <em>xprob^L</em>
ranges. This is done by specifying these numbers in <em>nxlone^D</em>,
where there are as many integers to be set as the dimension of the
problem.
<b>Note that it is necessary to have a consistent combination
of base grid resolution and the <em>-g=</em> setting for <em>$AMRVAC_DIR/setup.pl</em>:
the latter specifies the maximal individual grid resolution which
includes ghost cells at each side, while the <em>nxlone^D</em>
resolution must thus be a multiple of the individual grid resolution
without the ghost cells included</b>. An alternative way to
specify the domain resolution is to give the base grid cell size
directly using <em>dxlone^D</em>, but then again the same
restrictions apply, and one must be sure that the step size properly
divides the domain size (from the <em>xprob^L</em> pairs).
It is advocated to always use the integer setting through <em>nxlone^D</em>,
from which the code automatically computes the corresponding <em>dxlone^D</em>.
</p>
<h4>errorestimate, nbufferx^D, skipfinestep, amr_wavefilter</h4>
The code offers various choices for the error estimator used in
automatically detecting regions that need refinement.
<p>When <b>errorestimate=0</b>, all refinement
will only be based on the user-defined criteria to be coded up in
subroutine <em>specialrefine_grid</em>.
</p>
<p>When <b>errorestimate=1</b>, refinement at
time t_n will be based on a Richardson procedure where two low order
(using the typelow1 discretization) predictions of the future time
level t_(n+1) solution are computed and compared.
The two solutions are obtained by reversing the order of integrating
and coarsening. Note that only unsplit sources are taken into account
in this process, and that always a dimensionally unsplit scheme of
first order is used (in practice,
always tvdlf1). If this comparison should rather be done on two such
solutions at time t_n itself, one must set the <b>skipfinestep=F</b>.
</p>
<p>When <b>errorestimate=2</b>, we simply
compare the previous time level t_(n-1) solution with the present t_n
values, and trigger refinement on relative differences. </p>
<p>When <b>errorestimate=3</b>, the default
value, errors are estimated using current t_n values and
their gradients following Lohner's prescription. In this scheme, the <b>amr_wavefilter</b>
coefficient can be adjusted from its default value 0.01d0. You can set
different values for the wavefilter coefficient per grid level.
This error estimator is computationally efficient, and has shown
similar accuracy to the Richardson approach on a variety of test
problems.
</p>
<p>In all three latter cases, a call to the user defined
subroutine <em>specialrefine_grid</em> follows the error
estimator, making it possible to use this routine for augmented
user-controlled refinement, or even derefinement.
</p>
<p>Depending on the error estimator used, it is needed or
advisable to additionally provide a buffer zone of a certain number of
grid cells in width, which will surround cells that are flagged for
refinement by any other means. It will thus trigger more finer grids.
<b>nbufferx^D=2</b> is usually sufficient. It can never
be greater than the grid size specified with the -g setting of <em>$AMRVAC_DIR/setup.pl</em>.
For Lohner's scheme, the buffer can actually be turned off completely
by setting <b>nbufferx^D=0</b> which is default value.
</p>
<h4>flags, wflags, logflag, tol, tolratio</h4>
In all errorestimators mentioned above (except the errorestimate=0
case),
the comparison or evaluation is done only with a user-selected (sub)set
of the conserved variables. As there are <em>nw</em>
variables (which may include auxiliary variables such as predefined in
the special relativistic modules), the number of variables to be used
in the estimator is set by specifying it in <em>flags(nw+1)</em>.
Correspondingly, the first <em>flags(nw+1)</em> entries
for the flags array select their index
number, and corresponding weights are to be given in wflags. E.g., 3D
MHD has <em>nw=8</em>, and one can select refining based
on density, energy, and first component of the magnetic field by
setting flags(9)=3, flags(1)=1, flags(2)=5, flags(3)=6,
since we predefined the order <em>rho m1 m2 m3 e b1 b2 b3</em>.
The weights wflags(1), wflags(2), and wflags(3), must be positive
values between 0.0d0 and 1.0d0, and must add to unity. By default, only
the first conserved variable (typically density) is used in the
comparison.
<p>The Lohner error estimation (errorestimate=3) may also
decide to use differences in the log10(rho), and this is then done by
setting the <em>logflag(1)=T</em>. This can be done
per selected variables involved in the estimation, but obviously only
works for those that remain positive throughout.
</p>
<p>In the comparison involving the above selected variables,
when the total error exceeds the value set by <b>tol</b>,
the grid is triggered for refining. Reversely,
if the error drops below <b>tolratio * tol</b>, the grid
is coarsened. <b>The user must always set a (problem dependent)
value for <b>tol</b> (below 1), while the default value
for tolratio=1.0d0/8.0d0 has shown to be a rather generally useful
value. You can set tolerance values that differ per
refinement level. </b>
</p>
<p></p>
<h4>iprob</h4>
As a possible integer switch for selecting multiple problem setups in
the same executable code, the integer switch <b>iprob</b>
is provided. It is meant to be used only in the user-written
subroutines, for switching between e.g. multiple
initial conditions for the same executable.
<h4>prolongprimitive, coarsenprimitive, restrictprimitive,
amrentropy</h4>
It is possible to enforce the code to use primitive variables when
coarsening grid information (restriction), or
filling new finer level grids (prolongation). They are then used
instead of the conservative variables, which may not be a wise choice,
but is perhaps better behaved with respect to positivity of pressure
etc. This is activated seperately for prolongation by <b>prolongprimitive=T</b>,
and
for restriction by <b>restrictprimitive=T</b>. Also in the
Richardson error estimation process (when used), a coarsened grid is
created and this can be filled using the primitive
variables when <b>coarsenprimitive=T</b>. Again, this is
to be used with care.
<p>A much better strategy for handling positivity issues is
offered by means of
<b>amrentropy=T</b>. If one selects <b>amrentropy=T</b>,
the conserved energy variable is replaced by the conserved entropy
density (for HD and MHD only now) (and both restrictprimitive and
coarsenprimitive are overruled). The switch from energy to entropy
density is a general strategy, and is then used in all restriction and
prolongation phases.
By default, all these flags are set to false. For HD and MHD where the
switch from energy to
entropy is already precoded in their <em>amrvacphys.t.EQUATION</em>
module, we advocate the use of <b>amrentropy=T</b>.
</p>
<p>The parameters <b>tfixgrid, itfixgrid</b> are
available to fix the AMR hierarchical grid from a certain time onwards
(tfixgrid) or iteration (the it-counter for the timesteps) onwards
(itfixgrid). This may be handy for steady-state computations, or for
those cases where you know that the initial conditions and
physical setup is such that the AMR structure at t=0 will be optimal
for all times.The parameter <b>ditregrid</b> is introduced
to reconstruct the whole AMR grids once every ditregrid iteration(s)
instead of regridding once in every iteration by default.
</p>
</ol>
<h3><a name="Paramlist">Paramlist</a></h3>
<pre> &amp;paramlist<br>	dtpar= DOUBLE<br>	courantpar= DOUBLE<br> typecourant= 'maxsum' | 'summax' | 'minimum'<br>	dtdiffpar= DOUBLE<br>	dtTCpar= DOUBLE<br>	slowsteps= INTEGER<br> time_accurate= T | F<br> cfrac= DOUBLE<br><br>/<br></pre>
<ol>
<h4>dtpar, courantpar, typecourant, dtdiffpar, dtTCpar,
slowsteps</h4>
If <b>dtpar</b> is positive, it sets the timestep <b>dt</b>,
otherwise <b>courantpar</b> is used to limit the time step
based on the Courant condition. The default is <b>dtpar=-1.</b>
and <b>courantpar=0.8</b>.
<p>For resistive MHD, the time step is also limited by the
diffusion time:<br>
<b>dt &lt; dtdiffpar*dx^2/eta</b>. The default is <b>dtdiffpar=0.5</b>.
Further restrictions on the time step can be put in the <b>getdt_special</b>
subroutine in the <a href="amrvacusr.html#Specialsource">AMRVACUSR
module</a>.
The library routines for viscosity and div B diffusive cleaning,
all use the coefficient <b>dtdiffpar</b> in their
stability conditions. <b>dtTCpar</b> with default value of
0.5 limits the time step of thermal conduction.
</p>
<p>The <b>typecourant='maxsum'</b> means that
the time step limit for the CFL conditions takes the maximum over a
summed
contribution to the maximum physical propagation speed for all
dimensions. The detailed formulae are found in setdt.t.
</p>
<p>If the <b>slowsteps</b> parameter is set to a
positive integer value greater than 1, then in the first <b>slowsteps-1</b>
time steps <b>dt</b> is further reduced according to the
</p>
<pre> 2<br>dt'= dt * [ 1 - (1-step/slowsteps) ]<br></pre>
formula, where <b>step=1..slowsteps-1</b>. This reduction
can help to avoid problems resulting from numerically
unfavourable initial conditions, e.g. very sharp discontinuities. It is
normally inactive with a default value -1.
<p></p>
<h4>time_accurate</h4>
For steady state calculations, a grid-dependent value for the time step
can be used if the temporal
evolution is not interesting. This local time stepping strategy is
presently under construction, and hence we always have <b>time_accurate=T</b>.
<h4>cfrac</h4>
This is again specific for a cooling module for HD and MHD, as
developed by AJ van Marle,
described in AMRVAC_Man/<a href="mpiamrvac_radcool.html">mpiamrvac_radcool.html</a>.
</ol>
</ol>
<hr>
</body></html>